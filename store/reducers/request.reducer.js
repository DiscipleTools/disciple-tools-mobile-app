import * as actions from '../actions/request.actions';
import * as userActions from '../actions/user.actions';

import _ from 'lodash';

const initialState = {
  queue: [],
  currentAction: {},
};

export function generateLocalID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    /* eslint-disable */
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r && 0x3) | 0x8;
    /* eslint-enable */
    return v.toString(16);
  });
}

export default function requestReducer(state = initialState, action) {
  let newState = {
    ...state,
    currentAction: {},
  };
  let queue = [...newState.queue]; // clone array before modifying it
  const actionToModify = action.payload;
  switch (action.type) {
    case actions.REQUEST: {
      // Queue all requests
      if (actionToModify.data.method === 'POST' && actionToModify.action.includes('SAVE')) {
        // Map only POST requests
        let jsonBody = JSON.parse(actionToModify.data.body);
        if (Object.prototype.hasOwnProperty.call(action.payload, 'isConnected')) {
          const jsonBodyId = jsonBody.ID,
            { isConnected } = actionToModify;
          delete actionToModify.isConnected;
          if (isConnected) {
            // Phone its in ONLINE mode
            // REMOVE ALL AUTOGENERATED IDS FROM JSON
            Object.keys(jsonBody).forEach((key) => {
              const value = jsonBody[key];
              const valueType = Object.prototype.toString.call(value);
              if (
                valueType === '[object Array]' ||
                Object.prototype.hasOwnProperty.call(value, 'values')
              ) {
                let collectionHasValues, mappedValue;
                // "contact_" like field
                if (valueType === '[object Array]') {
                  collectionHasValues =
                    value.length > 0 &&
                    Object.prototype.toString.call(value[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value[0], 'value');
                  mappedValue = value;
                } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                  // { value: '' } array field
                  collectionHasValues =
                    value.values.length > 0 &&
                    Object.prototype.toString.call(value.values[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value.values[0], 'value');
                  mappedValue = value.values;
                }
                if (collectionHasValues) {
                  // Remove only AutogeneratedIDs of objects
                  mappedValue = mappedValue.map((object) => {
                    const copyObject = { ...object };
                    if (
                      copyObject.key &&
                      /^([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12})$/.test(
                        copyObject.key,
                      )
                    ) {
                      delete copyObject.key;
                    }
                    return copyObject;
                  });
                  if (valueType === '[object Array]') {
                    jsonBody = {
                      ...jsonBody,
                      [key]: mappedValue,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    jsonBody = {
                      ...jsonBody,
                      [key]: {
                        values: mappedValue,
                      },
                    };
                  }
                }
              } else {
                jsonBody = {
                  ...jsonBody,
                  [key]: value,
                };
              }
            });
          } else if (jsonBodyId) {
            // OFFLINE PUT ( Numeric ID / Autogenerated ID )

            // ADD AUTOGENERATED IDS TO { key: null, value: 'any' } OBJECTS
            Object.keys(jsonBody).forEach((key) => {
              const value = jsonBody[key];
              const valueType = Object.prototype.toString.call(value);
              if (
                valueType === '[object Array]' ||
                Object.prototype.hasOwnProperty.call(value, 'values')
              ) {
                let collectionHasValues;
                let mappedValue;
                // "contact_" like field
                if (valueType === '[object Array]') {
                  collectionHasValues =
                    value.length > 0 &&
                    Object.prototype.toString.call(value[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value[0], 'value');
                  mappedValue = value;
                } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                  // { key: '', value: '' } array field
                  collectionHasValues =
                    value.values.length > 0 &&
                    Object.prototype.toString.call(value.values[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value.values[0], 'value');
                  mappedValue = value.values;
                }
                if (collectionHasValues) {
                  // Add AutogeneratedID to new objects
                  mappedValue = mappedValue.map((object) => {
                    // Object has not key
                    if (!object.key) {
                      let existingKeyInCollection;
                      let temporalKey;
                      do {
                        // Generate key
                        temporalKey = generateLocalID();
                        // Check if generated key exist in collection
                        /* eslint-disable */
                        existingKeyInCollection = mappedValue.findIndex(
                          (objectItem) => objectItem.key === temporalKey,
                        );
                        /* eslint-enable */
                        // If ID exist, generate another one
                      } while (existingKeyInCollection > -1);
                      return {
                        ...object,
                        key: temporalKey,
                      };
                    }
                    return object;
                  });
                  if (valueType === '[object Array]') {
                    jsonBody = {
                      ...jsonBody,
                      [key]: mappedValue,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    jsonBody = {
                      ...jsonBody,
                      [key]: {
                        values: mappedValue,
                      },
                    };
                  }
                }
              } else {
                jsonBody = {
                  ...jsonBody,
                  [key]: value,
                };
              }
            });

            // SEARCH REQUEST IN QUEUE AND MERGE IT (IF EXIST)
            const requestIndex = queue.findIndex((request) => {
              let jsonParseBody;
              if (request.data.body) {
                jsonParseBody = JSON.parse(request.data.body);
              }
              return (
                actionToModify.action === request.action &&
                jsonParseBody &&
                jsonParseBody.ID === jsonBodyId
              );
            });
            if (requestIndex > -1) {
              let requestFromQueue = queue[requestIndex];
              const oldRequestBody = JSON.parse(requestFromQueue.data.body);
              let newRequestBody = {
                ...oldRequestBody,
              };
              // ADD CHANGES TO REQUEST BODY QUEUED (MERGE FIELDS OF TYPE COLLECTION AND OTHERS)
              Object.keys(jsonBody).forEach((key) => {
                const value = jsonBody[key];
                const valueType = Object.prototype.toString.call(value);
                if (
                  valueType === '[object Array]' ||
                  Object.prototype.hasOwnProperty.call(value, 'values')
                ) {
                  let collection, oldCollection;
                  if (valueType === '[object Array]') {
                    collection = value;
                    oldCollection = oldRequestBody[key] ? [...oldRequestBody[key]] : [];
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    collection = value.values;
                    oldCollection = oldRequestBody[key] ? [...oldRequestBody[key].values] : [];
                  }
                  // compare newCollection with oldCollection and merge differences.
                  collection.forEach((object) => {
                    // search object in oldRequestBody
                    let findObjectInOldRequestIndex = oldCollection.findIndex(
                      (oldObject) => object.key === oldObject.key,
                    );
                    if (findObjectInOldRequestIndex > -1) {
                      if (Object.prototype.hasOwnProperty.call(object, 'delete')) {
                        // remove object
                        oldCollection.splice(findObjectInOldRequestIndex, 1);
                      } else {
                        // update the object
                        oldCollection[findObjectInOldRequestIndex] = {
                          ...object,
                        };
                      }
                    } else {
                      // add the object
                      oldCollection.push({
                        ...object,
                      });
                    }
                  });
                  if (valueType === '[object Array]') {
                    newRequestBody = {
                      ...newRequestBody,
                      [key]: oldCollection,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    newRequestBody = {
                      ...newRequestBody,
                      [key]: {
                        values: oldCollection,
                      },
                    };
                  }
                } else {
                  newRequestBody = {
                    ...newRequestBody,
                    [key]: value,
                  };
                }
              });
              requestFromQueue = {
                ...requestFromQueue,
                data: {
                  ...requestFromQueue.data,
                  body: JSON.stringify(newRequestBody),
                },
              };
              queue[requestIndex] = {
                ...requestFromQueue,
              };
              // RETURN ONLY ENTITY CHANGES
              newState = {
                ...newState,
                queue: [...queue],
                currentAction: {
                  ...requestFromQueue,
                  data: {
                    ...requestFromQueue.data,
                    body: JSON.stringify(jsonBody),
                  },
                },
              };
              return newState;
            }
          } else {
            // OFFLINE POST (New entity, add autogenerated ID)
            let existingIdInQueue;
            let newID;
            do {
              // Generate ID
              /* eslint-disable */
              newID = generateLocalID();
              // Check if generated ID exist in queue
              existingIdInQueue = queue.findIndex(
                (request) =>
                  request.data.method === 'POST' &&
                  JSON.parse(request.data.body).ID &&
                  JSON.parse(request.data.body).ID === newID,
              );
              /* eslint-enable */
              // If ID exist, generate another one
            } while (existingIdInQueue > -1);
            // if not, use it
            jsonBody = {
              ...jsonBody,
              ID: newID,
            };
            // ADD AUTOGENERATED IDS TO { key: null, value: 'any' } OBJECTS
            Object.keys(jsonBody).forEach((key) => {
              const value = jsonBody[key];
              const valueType = Object.prototype.toString.call(value);
              if (
                valueType === '[object Array]' ||
                Object.prototype.hasOwnProperty.call(value, 'values')
              ) {
                let collectionHasValues;
                let mappedValue;
                // "contact_" like field
                if (valueType === '[object Array]') {
                  collectionHasValues =
                    value.length > 0 &&
                    Object.prototype.toString.call(value[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value[0], 'value');
                  mappedValue = value;
                } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                  // { key: '', value: '' } array field
                  collectionHasValues =
                    value.values.length > 0 &&
                    Object.prototype.toString.call(value.values[0]) === '[object Object]' &&
                    Object.prototype.hasOwnProperty.call(value.values[0], 'value');
                  mappedValue = value.values;
                }
                if (collectionHasValues) {
                  // Add AutogeneratedID to new objects
                  mappedValue = mappedValue.map((object) => {
                    if (!object.key) {
                      let existingKeyInCollection;
                      let temporalKey;
                      do {
                        // Generate key
                        temporalKey = generateLocalID();
                        // Check if generated key exist in collection
                        /* eslint-disable */
                        existingKeyInCollection = mappedValue.findIndex(
                          (objectItem) => objectItem.key === temporalKey,
                        );
                        /* eslint-enable */
                        // If ID exist, generate another one
                      } while (existingKeyInCollection > -1);
                      return {
                        ...object,
                        key: temporalKey,
                      };
                    }
                    return object;
                  });
                  if (valueType === '[object Array]') {
                    jsonBody = {
                      ...jsonBody,
                      [key]: mappedValue,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    jsonBody = {
                      ...jsonBody,
                      [key]: {
                        values: mappedValue,
                      },
                    };
                  }
                }
              } else {
                jsonBody = {
                  ...jsonBody,
                  [key]: value,
                };
              }
            });
          }
        }
        actionToModify.data.body = JSON.stringify(jsonBody);
      } else if (actionToModify.data.method === 'GET') {
        // filter out redundant GET requests (omit request with same URL and METHOD)
        queue = _.reject(queue, function (request) {
          return (
            request.url === actionToModify.url && request.data.method === actionToModify.data.method
          );
        });
      } else if (actionToModify.data.method === 'DELETE') {
        let urlSplit = actionToModify.url.split('/');
        // OFFLINE DELETE (comments)
        if (
          urlSplit[urlSplit.length - 2] === 'comments' &&
          Object.prototype.hasOwnProperty.call(actionToModify, 'isConnected') &&
          !actionToModify.isConnected
        ) {
          let id = urlSplit[urlSplit.length - 1];
          let urlWithoutId = actionToModify.url.replace(id, '');
          // Delete previous CREATE/EDIT request to the comment
          queue = queue.filter((existing) => existing.url !== urlWithoutId);

          // Add delete request ONLY if its ONLINE comment (not LOCAL)
          if (isNaN(id)) {
            queue = [...queue];
          } else {
            queue = [...queue, actionToModify];
          }
          return {
            ...newState,
            queue: queue,
            currentAction: actionToModify,
          };
        }
      }
      newState = {
        ...newState,
        queue: [...queue, actionToModify],
        currentAction: actionToModify,
      };
      return newState;
    }
    case actions.RESPONSE: {
      // loop through every item in local storage and filter out the successful request
      /* eslint-disable */
      let newQueue;
      /* eslint-enable */
      if (action.payload.data.method === 'POST') {
        newQueue = queue.filter(
          (request) =>
            request.action !== action.payload.action &&
            request.url !== action.payload.url &&
            request.data.method !== action.payload.data.method &&
            request.data.body &&
            JSON.parse(request.data.body).ID !== JSON.parse(action.payload.data.body).ID,
        );
      } else {
        newQueue = queue.filter(
          (request) =>
            request.action !== action.payload.action &&
            request.url !== action.payload.url &&
            request.data.method !== action.payload.data.method,
        );
      }
      newState = {
        ...newState,
        queue: [...newQueue],
      };
      return newState;
    }
    case userActions.USER_LOGOUT:
      return {
        queue: [],
        currentAction: {},
      };
    default:
      return newState;
  }
}
